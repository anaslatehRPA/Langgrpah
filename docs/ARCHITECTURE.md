# Project Architecture

This document describes the high-level architecture and data flow for the Project Planning RAG agent.

## Diagram (Mermaid)

The chart below shows components and the primary `state` keys they read/write.

```mermaid
flowchart LR
  User["User (query)"]
  DL[Document Loader<br/>(writes: `state["docs"]`, `state["vectorstore"]`)]
  VS["VectorStore<br/>(optional)"]
  RET[Retriever<br/>(reads: `state["query"]`, `state["docs"]`, `state["vectorstore"]`\nwrites: `state["retrieved_docs"]`)]
  GRADE["Grade Node<br/>(+ Rewrite loop)<br/>(reads: `state["retrieved_docs"]`, `state["docs"]`, `state["query"]`\nwrites: `state["is_relevant"]`, `state["rewrite_count"]`, `state["relevant_count"]`)"]
  PL[Planner<br/>(reads: `state["retrieved_docs"]`, `state["docs"]`\nwrites: `state["plan_summary"]`)]
  LLM[LLM Node<br/>(reads: `state["plan_summary"]`, `state["query"]`, `state["history"]`, `state["docs"]`\nwrites: `state["llm_answer"]`)]
  AREVAL["Answer Re-evaluation<br/>(reads: `state["llm_answer"]`, `state["plan_summary"]`\nwrites: `state["llm_answer"]`, `state["reeval_count"]`, `state["needs_reeval"]`)"]
  OUTPUT["Output<br/>(displays: `state["llm_answer"]`)"]

  User -->|query| RET
  DL -->|docs| RET
  DL --- VS
  RET -->|retrieved_docs| GRADE
  GRADE -->|is_relevant = true| PL
  GRADE -->|is_relevant = false: rewrite -> retriever loop| RET
  PL -->|plan_summary| LLM
  LLM -->|llm_answer| AREVAL
  AREVAL -->|needs_reeval = true -> refine (loop)| LLM
  AREVAL -->|final ->| OUTPUT

  subgraph Storage
    DL
    VS
  end
```

## Component responsibilities and state mapping

- Document Loader (`Rag_graph/nodes/document_loader_node.py`)
  - Reads: filesystem under `data/`
  - Writes: `state["docs"]` (dict filename -> content), `state["vectorstore"]` (optional)

- Retriever (`Rag_graph/nodes/retriever_node.py`)
  - Reads: `state["query"]`, `state["docs"]`, `state["vectorstore"]`
  - Writes: `state["retrieved_docs"]` (list of filenames or document ids)

- Grade Node (`Rag_graph/nodes/grade_node.py`)
  - Reads: `state["retrieved_docs"]`, `state["docs"]`, `state["query"]`
  - Behavior: checks relevance; if not relevant, calls `rewrite_query_node` to mutate `state["query"]` and re-invokes retriever up to `settings.MAX_REWRITE`.
  - Writes: `state["is_relevant"]`, `state["rewrite_count"]`, `state["relevant_count"]`

- Planner (`Rag_graph/nodes/planner_node.py`)
  - Reads: `state["retrieved_docs"]`, `state["docs"]`
  - Writes: `state["plan_summary"]`

- LLM Node (`Rag_graph/nodes/llm_node.py`)
  - Reads: `state["plan_summary"]`, `state["query"]`, `state["history"]`, and `state["docs"]` (for project-list detection)
  - Writes: `state["llm_answer"]`

- Answer Re-evaluation (`Rag_graph/nodes/answer_re_evaluation_node.py`)
  - Reads: `state["llm_answer"]`, `state["plan_summary"]`
  - If the answer misses keywords, may call `settings.LLM` with a re-eval prompt (`REEVAL_PROMPT`) to refine the answer, up to `settings.MAX_REEVALS`.
  - Writes: `state["llm_answer"]`, `state["llm_answer_original"]` (when refined), `state["reeval_count"]`, `state["needs_reeval"]`

## How to render the diagram locally

If you want a PNG rendered from the mermaid source, install the mermaid CLI and run:

```powershell
# install (requires node/npm)
npm install -g @mermaid-js/mermaid-cli

# render
mmdc -i docs/architecture.mmd -o docs/architecture.png
```

Or using npx (no global install):

```powershell
npx @mermaid-js/mermaid-cli -i docs/architecture.mmd -o docs/architecture.png
```

I will try to render `docs/architecture.mmd` to PNG automatically. If the render fails on your machine, use the commands above.

## Notes
- Debug output in nodes is privacy-safe and gated by `settings.DEBUG`.
- The re-write loop runs inside the Grade Node (in-place) and the Answer Re-evaluation is a separate node after LLM to refine outputs.

---

Generated by automation. If you want a PNG embedded in this repo, ask me to create it (I can attempt to render it here and add the file).
